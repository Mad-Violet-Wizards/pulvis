[1mdiff --git a/engine/core/Algorithm.cpp b/engine/core/Algorithm.cpp[m
[1mdeleted file mode 100644[m
[1mindex 58760b1..0000000[m
[1m--- a/engine/core/Algorithm.cpp[m
[1m+++ /dev/null[m
[36m@@ -1,2 +0,0 @@[m
[31m-#include "engine/engine_pch.hpp"[m
[31m-#include "Algorithm.hpp"[m
\ No newline at end of file[m
[1mdiff --git a/engine/core/Algorithm.hpp b/engine/core/Algorithm.hpp[m
[1mdeleted file mode 100644[m
[1mindex 2f419fe..0000000[m
[1m--- a/engine/core/Algorithm.hpp[m
[1m+++ /dev/null[m
[36m@@ -1,18 +0,0 @@[m
[31m-#pragma once[m
[31m-[m
[31m-namespace engine[m
[31m-{[m
[31m-namespace core[m
[31m-{[m
[31m-[m
[31m-	template<typename T>[m
[31m-	inline std::vector<T> Intersect(std::vector<T> _a, std::vector<T> _b)[m
[31m-	{[m
[31m-		std::vector<T> result;[m
[31m-		std::sort(_a.begin(), _a.end());[m
[31m-		std::sort(_b.begin(), _b.end());[m
[31m-		std::set_intersection(_a.begin(), _a.end(), _b.begin(), _b.end(), std::back_inserter(result));[m
[31m-		return result;[m
[31m-	}[m
[31m-}[m
[31m-}[m
[1mdiff --git a/engine/core/Application.cpp b/engine/core/Application.cpp[m
[1mindex 658e360..e7a1b44 100644[m
[1m--- a/engine/core/Application.cpp[m
[1m+++ b/engine/core/Application.cpp[m
[36m@@ -34,10 +34,6 @@[m [mnamespace engine[m
 		{[m
 			if (s_AppContext.m_AppSetup.m_ClientApp != EClientApp::Playground)[m
 				delete m_Window;[m
[31m-[m
[31m-			CLogger::Destroy();[m
[31m-			CAssertManager::Destroy();[m
[31m-			engine::events::CEventController::Destroy();[m
 		}[m
 [m
 [m
[1mdiff --git a/engine/engine_pch.hpp b/engine/engine_pch.hpp[m
[1mindex 3b4a924..80b066b 100644[m
[1m--- a/engine/engine_pch.hpp[m
[1m+++ b/engine/engine_pch.hpp[m
[36m@@ -22,12 +22,14 @@[m
 // +Engine[m
 //	 +Core[m
 #include "engine/core/Assert.hpp"[m
[31m-#include "engine/core/Algorithm.hpp"[m
[31m-#include "engine/core/Export.hpp"[m
 #include "engine/core/Logger.hpp"[m
 #include "engine/core/UUID.hpp"[m
 #include "engine/events/EventListener.hpp"[m
 #include "engine/events/EventController.hpp"[m
 //	-Core[m
 [m
[32m+[m[32m//	+pstd[m
[32m+[m[32m#include "engine/pstd/Intersects.hpp"[m
[32m+[m[32m//	-pstd[m
[32m+[m
 // -Engine[m
[1mdiff --git a/engine/events/EventBus.cpp b/engine/events/EventBus.cpp[m
[1mindex 9cf127b..bc6d0f9 100644[m
[1m--- a/engine/events/EventBus.cpp[m
[1m+++ b/engine/events/EventBus.cpp[m
[36m@@ -84,4 +84,8 @@[m [mnamespace engine::events[m
 			}[m
 		}[m
 	}[m
[32m+[m	[32mvoid CEventBus::ClearListeners()[m
[32m+[m	[32m{[m
[32m+[m		[32mm_EventListeners.clear();[m
[32m+[m	[32m}[m
 }[m
\ No newline at end of file[m
[1mdiff --git a/engine/events/EventBus.hpp b/engine/events/EventBus.hpp[m
[1mindex 80fbc3d..bb04abb 100644[m
[1m--- a/engine/events/EventBus.hpp[m
[1m+++ b/engine/events/EventBus.hpp[m
[36m@@ -31,6 +31,7 @@[m [mnamespace engine::events[m
 			void SendEvent(IEvent* _event);[m
 [m
 			void Frame();[m
[32m+[m			[32mvoid ClearListeners();[m
 [m
 	private:[m
 [m
[1mdiff --git a/engine/events/EventController.cpp b/engine/events/EventController.cpp[m
[1mindex cd1ad24..13dfa03 100644[m
[1m--- a/engine/events/EventController.cpp[m
[1m+++ b/engine/events/EventController.cpp[m
[36m@@ -20,6 +20,15 @@[m [mnamespace engine::events[m
 		}[m
 	}[m
 [m
[32m+[m	[32mvoid CEventController::ClearListeners()[m
[32m+[m	[32m{[m
[32m+[m		[32mfor (CEventBus& bus : m_EventBuses)[m
[32m+[m		[32m{[m
[32m+[m			[32mbus.ClearListeners();[m
[32m+[m		[32m}[m
[32m+[m[41m	[m
[32m+[m	[32m}[m
[32m+[m
 	void CEventController::SendEvent(IEvent* _event)[m
 	{[m
 		const EEventBus bus = _event->GetBusType();[m
[1mdiff --git a/engine/events/EventController.hpp b/engine/events/EventController.hpp[m
[1mindex e13950e..d63651b 100644[m
[1m--- a/engine/events/EventController.hpp[m
[1m+++ b/engine/events/EventController.hpp[m
[36m@@ -16,6 +16,7 @@[m [mnamespace engine::events[m
 		friend class Singleton<CEventController>;[m
 [m
 		void Frame();[m
[32m+[m		[32mvoid ClearListeners();[m
 [m
 		template<typename C>[m
 		void SubscribeEvent(IEventListener* _listener)[m
[1mdiff --git a/engine/rendering/Context.cpp b/engine/rendering/Context.cpp[m
[1mindex cddfa19..1adbc87 100644[m
[1m--- a/engine/rendering/Context.cpp[m
[1m+++ b/engine/rendering/Context.cpp[m
[36m@@ -12,7 +12,7 @@[m [mnamespace rendering[m
 	{[m
 		std::vector<std::string> vk_instance_layers;[m
 		FillInstanceLayers(vk_instance_layers, engine::rendering::s_DebugVerbose);[m
[31m-		m_VkEnabledInstanceLayers = engine::core::Intersect(vk_instance_layers, _requested_layers);[m
[32m+[m		[32mm_VkEnabledInstanceLayers = engine::pstd::Intersect(vk_instance_layers, _requested_layers);[m
 [m
 		if (engine::rendering::s_DebugVerbose)[m
 		{[m
[1mdiff --git a/engine/rtti/RTTIBase.hpp b/engine/rtti/RTTIBase.hpp[m
[1mindex decef4c..c990658 100644[m
[1m--- a/engine/rtti/RTTIBase.hpp[m
[1m+++ b/engine/rtti/RTTIBase.hpp[m
[36m@@ -20,5 +20,21 @@[m [mnamespace engine::rtti[m
 			{[m
 				return IsTypeOfId(CRTTITypeInfo<T>::GetTypeId());[m
 			}[m
[32m+[m
[32m+[m			[32mtemplate<typename T>[m
[32m+[m			[32mT* Cast() noexcept[m
[32m+[m			[32m{[m
[32m+[m				[32mreturn reinterpret_cast<T*>(const_cast<void*>(internal_cast(CRTTITypeInfo<T>::GetTypeId())));[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32mtemplate<typename T>[m
[32m+[m			[32mT const* Cast() const noexcept[m
[32m+[m			[32m{[m
[32m+[m				[32mreturn reinterpret_cast<T const*>(internal_cast(CRTTITypeInfo<T>::GetTypeId()));[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m		[32mprotected:[m
[32m+[m
[32m+[m			[32mvirtual void const* internal_cast(type_id_t _type_id) const noexcept = 0;[m
 	};[m
 }[m
[1mdiff --git a/engine/rtti/RTTIMacros.hpp b/engine/rtti/RTTIMacros.hpp[m
[1mindex de9cce1..e318ff3 100644[m
[1m--- a/engine/rtti/RTTIMacros.hpp[m
[1m+++ b/engine/rtti/RTTIMacros.hpp[m
[36m@@ -1,19 +1,98 @@[m
 #pragma once[m
 [m
[32m+[m[32m#include "engine/pstd/MacroUtils.hpp"[m
 #include "RTTITypeTraits.hpp"[m
[31m-#include "detail/RTTIEnumDetail.hpp"[m
[32m+[m[32m#include "RTTITypeName.hpp"[m
[32m+[m[32m#include "RTTITypeInfo.hpp"[m
[32m+[m[32m#include "RTTIMethodInfo.hpp"[m
[32m+[m[32m#include "RTTIMethod.hpp"[m
[32m+[m[32m#include "RTTIClass.hpp"[m
[32m+[m[32m#include "RTTIField.hpp"[m
[32m+[m[32m#include "detail/RTTIClassDetail.hpp"[m
 [m
[31m-#define RTTI_CLASS_API(className, ...)																							 \[m
[31m-public:																																							 \[m
[31m-	virtual engine::rtti::type_id_t GetTypeId() const override												 \[m
[31m-	{																																									 \[m
[31m-		return engine::rtti::CRTTITypeInfo<className, ##__VA_ARGS__>::GetTypeId();			 \[m
[31m-	}																																									 \[m
[31m-	virtual bool IsTypeOfId(engine::rtti::type_id_t _type) const override							 \[m
[31m-	{																																									 \[m
[31m-		return engine::rtti::CRTTITypeInfo<className, ##__VA_ARGS__>::IsTypeOfId(_type); \[m
[31m-	}																																								   \[m
[31m-																																										 \[m
[31m-[m
[31m-#define RTTI_ENUM_API(enumName) static engine::rtti::CRTTIEnum<enumName> s_Enum##enumName = {};[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////[m
[32m+[m[32mnamespace[m
[32m+[m[32m{[m
[32m+[m	[32mstatic void AttachParent(const char* _class_name, const char* _parent_name)[m
[32m+[m	[32m{[m
[32m+[m		[32mengine::rtti::detail::CRTTIClassStorage::FindClassByName(_class_name)->AttachParent(engine::rtti::detail::CRTTIClassStorage::FindClassByName(_parent_name));[m
[32m+[m	[32m}[m
 [m
[32m+[m	[32mtemplate<typename... Parents>[m
[32m+[m	[32mstatic void RegisterParents(const char* _classname)[m
[32m+[m	[32m{[m
[32m+[m		[32m(AttachParent(_classname, std::string(engine::rtti::CRTTITypeName::GetTypename<Parents>()).c_str()), ...);[m
[32m+[m	[32m}[m
[32m+[m[32m}[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m#define RTTI_CLASS_API(class_t, ...)																												  \[m
[32m+[m[32mpublic:																																										    \[m
[32m+[m	[32mvirtual engine::rtti::type_id_t GetTypeId() const override																  \[m
[32m+[m	[32m{																																													  \[m
[32m+[m		[32mreturn engine::rtti::CRTTITypeInfo<class_t, ##__VA_ARGS__>::GetTypeId();								  \[m
[32m+[m	[32m}																																													  \[m
[32m+[m	[32mvirtual bool IsTypeOfId(engine::rtti::type_id_t _type) const override											  \[m
[32m+[m	[32m{																																													  \[m
[32m+[m		[32mreturn engine::rtti::CRTTITypeInfo<class_t, ##__VA_ARGS__>::IsTypeOfId(_type);					  \[m
[32m+[m	[32m}																																													  \[m
[32m+[m	[32mvirtual void const* internal_cast(engine::rtti::type_id_t _type_id) const noexcept override \[m
[32m+[m	[32m{																																													  \[m
[32m+[m		[32mconst engine::rtti::type_id_t type_id = engine::rtti::CRTTITypeInfo<class_t, ##__VA_ARGS__>::GetTypeId();	\[m
[32m+[m		[32mif (type_id == _type_id)																																	\[m
[32m+[m		[32m{																																												  \[m
[32m+[m			[32mreturn engine::rtti::CRTTITypeInfo<class_t, ##__VA_ARGS__>::Cast(_type_id, this);				\[m
[32m+[m		[32m}																																												  \[m
[32m+[m		[32mreturn nullptr;																																						\[m
[32m+[m	[32m}																																													  \[m
[32m+[m[32mprivate:																																											\[m
[32m+[m[32m  struct CONCATENATE(SClassRegistrar_, class_t)																							  \[m
[32m+[m	[32m{																																													  \[m
[32m+[m		[32mCONCATENATE(SClassRegistrar_, class_t)()																								  \[m
[32m+[m		[32m{																																												  \[m
[32m+[m	[32m      const std::string class_name_str { engine::rtti::CRTTITypeName::GetTypename<class_t>() };	  \[m
[32m+[m				[32mstatic engine::rtti::CRTTIClass rtti_class(class_name_str.c_str());									  \[m
[32m+[m				[32mengine::rtti::detail::CRTTIClassStorage::RegisterClass(&rtti_class);												\[m
[32m+[m				[32mRegisterParents<__VA_ARGS__>(class_name_str.c_str());																  \[m
[32m+[m		[32m}																																												  \[m
[32m+[m	[32m};																																												  \[m
[32m+[m	[32minline static CONCATENATE(SClassRegistrar_, class_t) s_ClassRegistrar_##class_t{};				  \[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m#define RTTI_METHOD_API(class_t, method_t)																																																					\[m
[32m+[m[32mprivate:																																																																						\[m
[32m+[m[32m  inline static engine::rtti::CRTTIMethod CONCATENATE(s_Method_, CONCATENATE(class_t, method_t)) {#class_t, #method_t, &class_t::method_t};					\[m
[32m+[m	[32mstruct CONCATENATE(SMethodRegistrar_, CONCATENATE(class_t, method_t))																																							\[m
[32m+[m	[32m{																																																																									\[m
[32m+[m		[32mCONCATENATE(SMethodRegistrar_, CONCATENATE(class_t, method_t))()																																								\[m
[32m+[m		[32m{																																																																								\[m
[32m+[m			[32mconst std::string class_name_str { engine::rtti::CRTTITypeName::GetTypename<class_t>() };																											\[m
[32m+[m			[32mengine::rtti::CRTTIClass* rtti_class = engine::rtti::detail::CRTTIClassStorage::FindClassByName(class_name_str.c_str());														\[m
[32m+[m[32m      if (rtti_class)																																																																\[m
[32m+[m			[32m{																																																																							\[m
[32m+[m				[32mauto* method = &CONCATENATE(s_Method_, CONCATENATE(class_t, method_t));																																			\[m
[32m+[m				[32mrtti_class->AddMethod(method);																																																							\[m
[32m+[m			[32m}																																																																							\[m
[32m+[m		[32m}																																																																								\[m
[32m+[m	[32m};																																																																								\[m
[32m+[m	[32minline static CONCATENATE(SMethodRegistrar_, CONCATENATE(class_t, method_t)) CONCATENATE(s_MethodRegistrar, CONCATENATE(class_t, method_t)) = {}; \[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m#define RTTI_FIELD_API(class_t, field_name)																																																						\[m
[32m+[m[32mprivate:																																																																							\[m
[32m+[m	[32minline static engine::rtti::CRTTIField CONCATENATE(s_Field_, CONCATENATE(class_t, field_name)) {#field_name, &class_t::field_name};									\[m
[32m+[m	[32mstruct CONCATENATE(SFieldRegistrar_, CONCATENATE(class_t, field_name))																																							\[m
[32m+[m	[32m{																																																																										\[m
[32m+[m		[32mCONCATENATE(SFieldRegistrar_, CONCATENATE(class_t, field_name))()																																									\[m
[32m+[m		[32m{																																																																									\[m
[32m+[m			[32mconst std::string class_name_str{ engine::rtti::CRTTITypeName::GetTypename<class_t>() };																												\[m
[32m+[m			[32mengine::rtti::CRTTIClass* rtti_class = engine::rtti::detail::CRTTIClassStorage::FindClassByName(class_name_str.c_str());															\[m
[32m+[m			[32mif (rtti_class)																																																																	\[m
[32m+[m			[32m{																																																																								\[m
[32m+[m				[32mauto* field = &CONCATENATE(s_Field_, CONCATENATE(class_t, field_name));																																				\[m
[32m+[m				[32mrtti_class->AddField(field);																																																									\[m
[32m+[m			[32m}																																																																								\[m
[32m+[m		[32m}																																																																									\[m
[32m+[m	[32m};																																																																									\[m
[32m+[m	[32minline static CONCATENATE(SFieldRegistrar_, CONCATENATE(class_t, field_name)) CONCATENATE(s_FieldRegistrar, CONCATENATE(class_t, field_name)) = {}; \[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m#define RTTI_ENUM_API(enumName)																					\[m
[32m+[m[32minline static engine::rtti::CRTTIEnum<enumName> s_Enum_##enumName = {}; \[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////[m
[1mdiff --git a/engine/rtti/RTTITypeInfo.hpp b/engine/rtti/RTTITypeInfo.hpp[m
[1mindex fa57574..c2692c3 100644[m
[1m--- a/engine/rtti/RTTITypeInfo.hpp[m
[1m+++ b/engine/rtti/RTTITypeInfo.hpp[m
[36m@@ -45,5 +45,21 @@[m [mnamespace engine::rtti[m
 [m
 				return false;[m
 			}[m
[32m+[m
[32m+[m			[32mtemplate<typename T>[m
[32m+[m			[32mstatic void const* Cast(type_id_t _type_id, T const* ptr) noexcept[m
[32m+[m			[32m{[m
[32m+[m				[32mif (GetTypeId() == _type_id)[m
[32m+[m				[32m{[m
[32m+[m					[32mreturn static_cast<T const*>(ptr);[m
[32m+[m				[32m}[m
[32m+[m
[32m+[m				[32mif constexpr (sizeof...(Parents) > 0)[m
[32m+[m				[32m{[m
[32m+[m					[32m(... || CRTTITypeInfo<Parents>::Cast(_type_id, ptr));[m
[32m+[m				[32m}[m
[32m+[m
[32m+[m				[32mreturn nullptr;[m
[32m+[m			[32m}[m
 	};[m
 }[m
\ No newline at end of file[m
[1mdiff --git a/engine/rtti/RTTITypeName.hpp b/engine/rtti/RTTITypeName.hpp[m
[1mindex 4c69b80..e3c3ff7 100644[m
[1m--- a/engine/rtti/RTTITypeName.hpp[m
[1m+++ b/engine/rtti/RTTITypeName.hpp[m
[36m@@ -1,5 +1,7 @@[m
 #pragma once[m
 [m
[32m+[m[32m#include "engine/core/Export.hpp"[m
[32m+[m
 namespace engine::rtti[m
 {[m
 	class PULVIS_API CRTTITypeName[m
[1mdiff --git a/engine/rtti/RTTITypeTraits.hpp b/engine/rtti/RTTITypeTraits.hpp[m
[1mindex 28c7bb2..00e6f69 100644[m
[1m--- a/engine/rtti/RTTITypeTraits.hpp[m
[1m+++ b/engine/rtti/RTTITypeTraits.hpp[m
[36m@@ -5,4 +5,5 @@[m
 namespace engine::rtti[m
 {[m
 	using type_id_t = uint32_t;[m
[32m+[m	[32mconstexpr static type_id_t INVALID_TYPE_ID = UINT32_MAX;[m
 }[m
[1mdiff --git a/engine/rtti/detail/RTTIEnumDetail.hpp b/engine/rtti/detail/RTTIEnumDetail.hpp[m
[1mindex 4d929d6..31c2c48 100644[m
[1m--- a/engine/rtti/detail/RTTIEnumDetail.hpp[m
[1m+++ b/engine/rtti/detail/RTTIEnumDetail.hpp[m
[36m@@ -1,10 +1,10 @@[m
 #pragma once[m
 [m
 #include "engine/rtti/RTTITypeName.hpp"[m
[31m-#include "engine/rtti/RTTIMacros.hpp"[m
 [m
 namespace engine::rtti::detail[m
 {[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////[m
 	namespace enum_detail[m
 	{[m
 		static constexpr int s_CheckValuesLimit = 256;[m
[36m@@ -30,9 +30,9 @@[m [mnamespace engine::rtti::detail[m
 				std::vector<SEnumData> m_EnumData;[m
 				bool m_Valid = false;[m
 			};[m
[31m-[m
[31m-			static inline std::array<SEnumDataBuffer, s_MapperBufferLimit> s_EnumDataStorage = {};[m
 		}[m
[32m+[m		[32mstatic inline std::array<SEnumDataBuffer, s_MapperBufferLimit> s_EnumDataStorage = {};[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////[m
 [m
 		template<typename E>[m
 		static int GetEnumCount()[m
[1mdiff --git a/engine/threads/ThreadFunctionWrapper.cpp b/engine/threads/ThreadFunctionWrapper.cpp[m
[1mdeleted file mode 100644[m
[1mindex 3e674dd..0000000[m
[1m--- a/engine/threads/ThreadFunctionWrapper.cpp[m
[1m+++ /dev/null[m
[36m@@ -1 +0,0 @@[m
[31m-#include "engine/engine_pch.hpp"[m
\ No newline at end of file[m
[1mdiff --git a/engine/threads/ThreadFunctionWrapper.hpp b/engine/threads/ThreadFunctionWrapper.hpp[m
[1mdeleted file mode 100644[m
[1mindex bdfd529..0000000[m
[1m--- a/engine/threads/ThreadFunctionWrapper.hpp[m
[1m+++ /dev/null[m
[36m@@ -1,130 +0,0 @@[m
[31m-#pragma once[m
[31m-[m
[31m-namespace engine::threads[m
[31m-{[m
[31m-	template<typename R, typename... Args>[m
[31m-	class CThreadFunctionWrapper[m
[31m-	{[m
[31m-	public:[m
[31m-[m
[31m-		CThreadFunctionWrapper()[m
[31m-			: m_Invoker(nullptr)[m
[31m-			, m_Destructor(nullptr) [m
[31m-		{[m
[31m-		}[m
[31m-[m
[31m-		~CThreadFunctionWrapper()[m
[31m-		{[m
[31m-			Destroy();[m
[31m-		}[m
[31m-[m
[31m-		using function_t = R(*)(Args...);[m
[31m-[m
[31m-		template<typename Func>[m
[31m-		CThreadFunctionWrapper(Func&& _func)[m
[31m-		{[m
[31m-			using function_unref_t = std::decay_t<Func>;[m
[31m-			static_assert(sizeof(function_unref_t) < sizeof(m_StorageBuffer), "Function object is too big to fit in the buffer");[m
[31m-			new (static_cast<void*>(&m_StorageBuffer)) function_unref_t(std::forward<Func>(_func));[m
[31m-[m
[31m-			m_Invoker = [](void* _buffer, Args... _args) -> R[m
[31m-				{[m
[31m-					auto& function_ref = *static_cast<function_unref_t*>(_buffer);[m
[31m-					static_assert(std::is_same<R, decltype(function_ref(std::forward<Args>(_args)...))>::value, "Type mismatch!");[m
[31m-[m
[31m-					return function_ref(std::forward<Args>(_args)...);[m
[31m-				};[m
[31m-[m
[31m-			m_Destructor = [](void* _buffer)[m
[31m-				{[m
[31m-					static_cast<function_unref_t*>(_buffer)->~function_unref_t();[m
[31m-				};[m
[31m-		}[m
[31m-[m
[31m-		template<class C>[m
[31m-		CThreadFunctionWrapper(C* _instance, R(C::* _method)(Args...))[m
[31m-		{[m
[31m-			struct SClassMethodWrapper[m
[31m-			{[m
[31m-				C* m_Instance;[m
[31m-				R(C::* m_Methdod)(Args...);[m
[31m-[m
[31m-				SClassMethodWrapper(C* _instance, R(C::* _method)(Args...))[m
[31m-					: m_Instance(_instance)[m
[31m-					, m_Methdod(_method) {}[m
[31m-[m
[31m-				R operator()(Args&&... _args)[m
[31m-				{[m
[31m-					return (m_Instance->*m_Methdod)(std::forward<Args>(_args)...);[m
[31m-				}[m
[31m-			};[m
[31m-[m
[31m-			static_assert(sizeof(SClassMethodWrapper) < sizeof(m_StorageBuffer), "Function object is too big to fit in the buffer");[m
[31m-			new (static_cast<void*>(&m_StorageBuffer)) SClassMethodWrapper(_instance, _method);[m
[31m-[m
[31m-			m_Invoker = +[](void* buffer, Args... args) -> R[m
[31m-				{[m
[31m-					auto& method_ref = *static_cast<SClassMethodWrapper*>(buffer);[m
[31m-					return method_ref(std::forward<Args>(args)...);[m
[31m-				};[m
[31m-[m
[31m-			m_Destructor = [](void* buffer)[m
[31m-				{[m
[31m-					static_cast<SClassMethodWrapper*>(buffer)->~SClassMethodWrapper();[m
[31m-				};[m
[31m-		}[m
[31m-[m
[31m-		CThreadFunctionWrapper(const CThreadFunctionWrapper& _other) = delete;[m
[31m-		CThreadFunctionWrapper& operator=(const CThreadFunctionWrapper& _other) = delete;[m
[31m-[m
[31m-		CThreadFunctionWrapper(CThreadFunctionWrapper&& _other) noexcept[m
[31m-		{[m
[31m-			std::memcpy(&m_StorageBuffer, &_other.m_StorageBuffer, sizeof(m_StorageBuffer));[m
[31m-			m_Invoker = _other.m_Invoker;[m
[31m-			m_Destructor = _other.m_Destructor;[m
[31m-			_other.m_Invoker = nullptr;[m
[31m-			_other.m_Destructor = nullptr;[m
[31m-		}[m
[31m-[m
[31m-		CThreadFunctionWrapper& operator=(CThreadFunctionWrapper&& _other) noexcept[m
[31m-		{[m
[31m-			if (this != &_other)[m
[31m-			{[m
[31m-				Destroy();[m
[31m-				std::memcpy(&m_StorageBuffer, &_other.m_StorageBuffer, sizeof(m_StorageBuffer));[m
[31m-				m_Invoker = _other.m_Invoker;[m
[31m-				m_Destructor = _other.m_Destructor;[m
[31m-				_other.m_Invoker = nullptr;[m
[31m-				_other.m_Destructor = nullptr;[m
[31m-			}[m
[31m-[m
[31m-			return *this;[m
[31m-		}[m
[31m-[m
[31m-		R operator()(Args&&... args)[m
[31m-		{[m
[31m-			return m_Invoker(&m_StorageBuffer, std::forward<Args>(args)...);[m
[31m-		}[m
[31m-[m
[31m-	private:[m
[31m-[m
[31m-		void Destroy()[m
[31m-		{[m
[31m-			if (m_Destructor)[m
[31m-			{[m
[31m-				m_Destructor(&m_StorageBuffer);[m
[31m-			}[m
[31m-		}[m
[31m-[m
[31m-	private:[m
[31m-[m
[31m-		static constexpr size_t s_BufferSize = 128;[m
[31m-		typename std::aligned_storage<s_BufferSize, sizeof(size_t)>::type m_StorageBuffer;[m
[31m-[m
[31m-		using Invoker = R(*)(void*, Args...);[m
[31m-		using Destructor = void(*)(void*);[m
[31m-[m
[31m-		Destructor m_Destructor;[m
[31m-		Invoker m_Invoker;[m
[31m-	};[m
[31m-}[m
\ No newline at end of file[m
[1mdiff --git a/engine/threads/ThreadTask.hpp b/engine/threads/ThreadTask.hpp[m
[1mindex 385ca23..1174533 100644[m
[1m--- a/engine/threads/ThreadTask.hpp[m
[1m+++ b/engine/threads/ThreadTask.hpp[m
[36m@@ -4,7 +4,7 @@[m
 #include <functional>[m
 #include <type_traits>[m
 [m
[31m-#include "ThreadFunctionWrapper.hpp"[m
[32m+[m[32m#include "engine/pstd/FastFunction.hpp"[m
 [m
 /* engine::threads::detail */[m
 namespace engine::threads::detail[m
[36m@@ -73,7 +73,7 @@[m [mnamespace engine::threads::detail[m
 [m
 		private:[m
 [m
[31m-			CThreadFunctionWrapper<R, Args...> m_Function;[m
[32m+[m			[32mpstd::FastFunction<R, Args...> m_Function;[m
 			std::tuple<Args...> m_Args;[m
 			std::promise<std::decay_t<R>> m_Promise;[m
 	};[m
[36m@@ -125,7 +125,7 @@[m [mnamespace engine::threads::detail[m
 [m
 	private:[m
 [m
[31m-		CThreadFunctionWrapper<R, Args...> m_Function;[m
[32m+[m		[32mpstd::FastFunction<R, Args...> m_Function;[m
 		std::tuple<Args...> m_Args;[m
 		std::promise<std::decay_t<R>> m_Promise;[m
 	};[m
[1mdiff --git a/playground/main.cpp b/playground/main.cpp[m
[1mindex cfe9f72..224f408 100644[m
[1m--- a/playground/main.cpp[m
[1m+++ b/playground/main.cpp[m
[36m@@ -1,5 +1,3 @@[m
[31m-#include <iostream>[m
[31m-[m
 #include <vendor/common/include/catch2/catch2.hpp>[m
 [m
 int main(int argc, char* argv[])[m
[1mdiff --git a/playground/tests/EventTests.hpp b/playground/tests/EventTests.hpp[m
[1mindex c967c9e..345101b 100644[m
[1m--- a/playground/tests/EventTests.hpp[m
[1m+++ b/playground/tests/EventTests.hpp[m
[36m@@ -112,12 +112,12 @@[m [mnamespace engine::events[m
 				m_Listener2 = std::make_unique<MocEventListener2>();[m
 			}[m
 [m
[31m-			MocEventListener* GetListener() const[m
[32m+[m			[32mMocEventListener* GetListener()[m
 			{[m
 				return m_Listener.get();[m
 			}[m
 [m
[31m-			MocEventListener2* GetListener2() const[m
[32m+[m			[32mMocEventListener2* GetListener2()[m
 			{[m
 				return m_Listener2.get();[m
 			}[m
[1mdiff --git a/playground/tests/EventsTests.cpp b/playground/tests/EventsTests.cpp[m
[1mindex f44d996..77d9e65 100644[m
[1m--- a/playground/tests/EventsTests.cpp[m
[1m+++ b/playground/tests/EventsTests.cpp[m
[36m@@ -15,6 +15,7 @@[m [mTEST_CASE_METHOD(engine::events::tests::EventTestsFixture, "EventTests")[m
 		REQUIRE(event->GetProcessTime() == EProcessTime::Immediate);[m
 		CEventController::GetInstance().SendEvent(event.get());[m
 		REQUIRE(event->m_Handled == true);[m
[32m+[m		[32mCEventController::GetInstance().ClearListeners();[m
 	}[m
 [m
 	SECTION("Is next frame event proccessed properly?")[m
[36m@@ -26,6 +27,7 @@[m [mTEST_CASE_METHOD(engine::events::tests::EventTestsFixture, "EventTests")[m
 		REQUIRE(event->m_Handled == false);[m
 		m_Application->FrameCycle();[m
 		REQUIRE(event->m_Handled == true);[m
[32m+[m		[32mCEventController::GetInstance().ClearListeners();[m
 	}[m
 [m
 	SECTION("Events on different buses?")[m
[36m@@ -40,6 +42,7 @@[m [mTEST_CASE_METHOD(engine::events::tests::EventTestsFixture, "EventTests")[m
 		CEventController::GetInstance().SendEvent(event2.get());[m
 		REQUIRE(event->m_Handled == true);[m
 		REQUIRE(event2->m_Handled == true);[m
[32m+[m		[32mCEventController::GetInstance().ClearListeners();[m
 	}[m
 [m
 	SECTION("Unsubscribed event is not proccesed?")[m
[36m@@ -48,9 +51,10 @@[m [mTEST_CASE_METHOD(engine::events::tests::EventTestsFixture, "EventTests")[m
 [m
 		std::unique_ptr<MocEventBool> event3 = CreateEvent<MocEventBool>();[m
 		event3->m_Handled = false;[m
[31m-		CEventController::GetInstance().UnsubscribeEvent<MocEventBool>(m_Listener.get());[m
[32m+[m		[32mCEventController::GetInstance().UnsubscribeEvent<MocEventBool>(GetListener());[m
 		CEventController::GetInstance().SendEvent(event3.get());[m
 		REQUIRE(event3->m_Handled == false);[m
[32m+[m		[32mCEventController::GetInstance().ClearListeners();[m
 	}[m
 [m
 	SECTION("Two event listeners on same event?")[m
[36m@@ -62,6 +66,7 @@[m [mTEST_CASE_METHOD(engine::events::tests::EventTestsFixture, "EventTests")[m
 		CEventController::GetInstance().SendEvent(event4.get());[m
 		REQUIRE(event4->m_Handled == true);[m
 		REQUIRE(event4->m_Handled2 == true);[m
[32m+[m		[32mCEventController::GetInstance().ClearListeners();[m
 	}[m
 [m
 	SECTION("Two event listeners but one unsubscribes?")[m
[36m@@ -74,6 +79,7 @@[m [mTEST_CASE_METHOD(engine::events::tests::EventTestsFixture, "EventTests")[m
 		CEventController::GetInstance().SendEvent(event4.get());[m
 		REQUIRE(event4->m_Handled == true);[m
 		REQUIRE(event4->m_Handled2 == false);[m
[32m+[m		[32mCEventController::GetInstance().ClearListeners();[m
 	}[m
 [m
 #if defined(BENCHMARKING)[m
[36m@@ -88,6 +94,7 @@[m [mTEST_CASE_METHOD(engine::events::tests::EventTestsFixture, "EventTests")[m
 				CEventController::GetInstance().SendEvent(event.get());[m
 			}[m
 		};[m
[32m+[m		[32mCEventController::GetInstance().ClearListeners();[m
 	}[m
 #endif[m
 }[m
\ No newline at end of file[m
[1mdiff --git a/playground/tests/RTTITests.cpp b/playground/tests/RTTITests.cpp[m
[1mindex e0a3ef4..3be3203 100644[m
[1m--- a/playground/tests/RTTITests.cpp[m
[1m+++ b/playground/tests/RTTITests.cpp[m
[36m@@ -6,14 +6,14 @@[m
 [m
 #include <vendor/common/include/catch2/catch2.hpp>[m
 [m
[31m-using namespace engine::rtti;[m
[31m-using namespace engine::rtti::detail;[m
[31m-using namespace engine::rtti::tests;[m
[31m-[m
 TEST_CASE("Type name tests", "[RTTI]")[m
 {[m
 	SECTION("Simple types ok?")[m
 	{[m
[32m+[m		[32musing namespace engine::rtti;[m
[32m+[m		[32musing namespace engine::rtti::detail;[m
[32m+[m		[32musing namespace engine::rtti::tests;[m
[32m+[m
 		constexpr std::string_view int_typename = CRTTITypeName::GetTypename<int>();[m
 		REQUIRE(int_typename == "int");[m
 [m
[36m@@ -35,6 +35,10 @@[m [mTEST_CASE("Type name tests", "[RTTI]")[m
 [m
 	SECTION("Class types ok?")[m
 	{[m
[32m+[m		[32musing namespace engine::rtti;[m
[32m+[m		[32musing namespace engine::rtti::detail;[m
[32m+[m		[32musing namespace engine::rtti::tests;[m
[32m+[m
 		constexpr std::string_view simple_struct_typename = CRTTITypeName::GetTypename<SSimpleStruct>();[m
 		REQUIRE(simple_struct_typename == "engine::rtti::tests::SSimpleStruct");[m
 [m
[36m@@ -87,6 +91,10 @@[m [mTEST_CASE("IsTypeOf", "[RTTI]")[m
 {[m
 	SECTION("Simple types ok?")[m
 	{[m
[32m+[m		[32musing namespace engine::rtti;[m
[32m+[m		[32musing namespace engine::rtti::detail;[m
[32m+[m		[32musing namespace engine::rtti::tests;[m
[32m+[m
 		REQUIRE(CRTTITypeInfo<int>::IsTypeOfId(CRTTITypeInfo<int>::GetTypeId()));[m
 		REQUIRE(CRTTITypeInfo<float>::IsTypeOfId(CRTTITypeInfo<float>::GetTypeId()));[m
 		REQUIRE(CRTTITypeInfo<double>::IsTypeOfId(CRTTITypeInfo<double>::GetTypeId()));[m
[36m@@ -97,6 +105,10 @@[m [mTEST_CASE("IsTypeOf", "[RTTI]")[m
 [m
 	SECTION("Class types ok?")[m
 	{[m
[32m+[m		[32musing namespace engine::rtti;[m
[32m+[m		[32musing namespace engine::rtti::detail;[m
[32m+[m		[32musing namespace engine::rtti::tests;[m
[32m+[m
 		CDerived derived;[m
 [m
 		std::cout << derived.GetTypeId() << std::endl;[m
[36m@@ -119,11 +131,19 @@[m [mTEST_CASE("Enum API", "[RTTI]")[m
 {[m
 	SECTION("Name is extracted properly?")[m
 	{[m
[32m+[m		[32musing namespace engine::rtti;[m
[32m+[m		[32musing namespace engine::rtti::detail;[m
[32m+[m		[32musing namespace engine::rtti::tests;[m
[32m+[m
 		constexpr std::string_view rtti_enum_explicit_name = CRTTIEnum<EMocRttiEnumExplicit>::GetName();[m
 	}[m
 [m
 	SECTION("Count is ok?")[m
 	{[m
[32m+[m		[32musing namespace engine::rtti;[m
[32m+[m		[32musing namespace engine::rtti::detail;[m
[32m+[m		[32musing namespace engine::rtti::tests;[m
[32m+[m
 		const int rtti_enum_explicit_count = CRTTIEnum<EMocRttiEnumExplicit>::GetCount();[m
 		REQUIRE(rtti_enum_explicit_count == 6);[m
 [m
[36m@@ -137,6 +157,10 @@[m [mTEST_CASE("Enum API", "[RTTI]")[m
 [m
 	SECTION("To String?")[m
 	{[m
[32m+[m		[32musing namespace engine::rtti;[m
[32m+[m		[32musing namespace engine::rtti::detail;[m
[32m+[m		[32musing namespace engine::rtti::tests;[m
[32m+[m
 		const std::string_view rtti_explicit_a_value = CRTTIEnum<EMocRttiEnumExplicit>::ToString(EMocRttiEnumExplicit::A);[m
 		REQUIRE(rtti_explicit_a_value == "A");[m
 [m
[36m@@ -149,6 +173,10 @@[m [mTEST_CASE("Enum API", "[RTTI]")[m
 [m
 	SECTION("From String?")[m
 	{[m
[32m+[m		[32musing namespace engine::rtti;[m
[32m+[m		[32musing namespace engine::rtti::detail;[m
[32m+[m		[32musing namespace engine::rtti::tests;[m
[32m+[m
 		constexpr std::string_view rtti_explicit_a = "A";[m
 		const EMocRttiEnumExplicit rtti_explicit_a_value = CRTTIEnum<EMocRttiEnumExplicit>::FromString(rtti_explicit_a);[m
 		REQUIRE(rtti_explicit_a_value == EMocRttiEnumExplicit::A);[m
[36m@@ -161,4 +189,126 @@[m [mTEST_CASE("Enum API", "[RTTI]")[m
 		const EMocRttiLongValuesNames rtti_long_names_f_value = CRTTIEnum<EMocRttiLongValuesNames>::FromString(rtti_long_names_f);[m
 		REQUIRE(rtti_long_names_f_value == EMocRttiLongValuesNames::NoTakWlasnieBywaZeWZyciuNiewielePrzybywaAleZaToWieleOdplywa);[m
 	}[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mTEST_CASE("RTTI Classes", "[RTTI]")[m
[32m+[m[32m{[m
[32m+[m	[32mSECTION("Classes are registered properly?")[m
[32m+[m	[32m{[m
[32m+[m		[32musing namespace engine::rtti;[m
[32m+[m		[32musing namespace engine::rtti::detail;[m
[32m+[m		[32musing namespace engine::rtti::tests;[m
[32m+[m
[32m+[m		[32mCRTTIClass* rtti_class = CRTTIClass::FindInStorage("engine::rtti::tests::CDerived");[m
[32m+[m		[32mREQUIRE(rtti_class != nullptr);[m
[32m+[m		[32mREQUIRE(rtti_class->GetName() == "engine::rtti::tests::CDerived");[m
[32m+[m
[32m+[m		[32mCRTTIClass* rtti_class2 = CRTTIClass::FindInStorage("engine::rtti::tests::CDerived2");[m
[32m+[m		[32mREQUIRE(rtti_class2 != nullptr);[m
[32m+[m		[32mREQUIRE(rtti_class2->GetName() == "engine::rtti::tests::CDerived2");[m
[32m+[m
[32m+[m		[32mCRTTIClass* rtti_class3 = CRTTIClass::FindInStorage("engine::rtti::tests::IBase");[m
[32m+[m		[32mREQUIRE(rtti_class3 != nullptr);[m
[32m+[m		[32mREQUIRE(rtti_class3->GetName() == "engine::rtti::tests::IBase");[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32mSECTION("Casting works?")[m
[32m+[m	[32m{[m
[32m+[m		[32musing namespace engine::rtti;[m
[32m+[m		[32musing namespace engine::rtti::detail;[m
[32m+[m		[32musing namespace engine::rtti::tests;[m
[32m+[m
[32m+[m		[32mIBase* base = new CDerived();[m
[32m+[m		[32mIBase* base2 = new CDerived2();[m
[32m+[m		[32mIBase* base3 = new CDerivedBoth();[m
[32m+[m		[32mIBase2* base4 = new CDerivedBoth();[m
[32m+[m
[32m+[m		[32mbase->Cast<CDerived>();[m
[32m+[m		[32mbase2->Cast<CDerived2>();[m
[32m+[m		[32mbase3->Cast<CDerivedBoth>();[m
[32m+[m		[32mbase4->Cast<CDerivedBoth>();[m
[32m+[m
[32m+[m		[32mREQUIRE(base != nullptr);[m
[32m+[m		[32mREQUIRE(base2 != nullptr);[m
[32m+[m		[32mREQUIRE(base3 != nullptr);[m
[32m+[m		[32mREQUIRE(base4 != nullptr);[m
[32m+[m
[32m+[m		[32mREQUIRE(typeid(*base) == typeid(CDerived));[m
[32m+[m		[32mREQUIRE(typeid(*base2) == typeid(CDerived2));[m
[32m+[m		[32mREQUIRE(typeid(*base3) == typeid(CDerivedBoth));[m
[32m+[m		[32mREQUIRE(typeid(*base4) == typeid(CDerivedBoth));[m
[32m+[m
[32m+[m		[32mdelete base;[m
[32m+[m		[32mdelete base2;[m
[32m+[m		[32mdelete base3;[m
[32m+[m		[32mdelete base4;[m
[32m+[m
[32m+[m	[32m}[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mTEST_CASE("RTTI Methods", "[RTTI]")[m
[32m+[m[32m{[m
[32m+[m	[32mSECTION("Methods are registered and called properly?")[m
[32m+[m	[32m{[m
[32m+[m		[32musing namespace engine::rtti;[m
[32m+[m		[32musing namespace engine::rtti::tests;[m
[32m+[m
[32m+[m		[32mCDerived derived;[m
[32m+[m		[32mCDerived2 derived2;[m
[32m+[m		[32mCDerivedBoth derived_both;[m
[32m+[m
[32m+[m		[32mCRTTIClass* rtti_class_base = CRTTIClass::FindInStorage("engine::rtti::tests::IBase");[m
[32m+[m		[32mREQUIRE(rtti_class_base != nullptr);[m
[32m+[m
[32m+[m		[32mCRTTIMethod* rtti_method_add = rtti_class_base->FindMethodByName("Add");[m
[32m+[m		[32mREQUIRE(rtti_method_add != nullptr);[m
[32m+[m		[32mint add_result = rtti_method_add->Invoke<int>(&derived, 5, 3);[m
[32m+[m		[32mREQUIRE(add_result == 8);[m
[32m+[m
[32m+[m		[32mCRTTIMethod* rtti_method_subtract = rtti_class_base->FindMethodByName("Subtract");[m
[32m+[m		[32mREQUIRE(rtti_method_subtract != nullptr);[m
[32m+[m		[32mint subtract_result = rtti_method_subtract->Invoke<int>(&derived, 5, 3);[m
[32m+[m		[32mREQUIRE(subtract_result == 2);[m
[32m+[m
[32m+[m		[32mCRTTIClass* rtti_class_base2 = CRTTIClass::FindInStorage("engine::rtti::tests::IBase2");[m
[32m+[m		[32mREQUIRE(rtti_class_base2 != nullptr);[m
[32m+[m		[32mCRTTIMethod* rtti_method_multiply = rtti_class_base2->FindMethodByName("Multiply");[m
[32m+[m		[32mREQUIRE(rtti_method_multiply != nullptr);[m
[32m+[m		[32mint multiply_result = rtti_method_multiply->Invoke<int>(&derived_both, 5, 3);[m
[32m+[m		[32mREQUIRE(multiply_result == 15);[m
[32m+[m
[32m+[m		[32mCRTTIMethod* rtti_method_divide = rtti_class_base2->FindMethodByName("Divide");[m
[32m+[m		[32mREQUIRE(rtti_method_divide != nullptr);[m
[32m+[m		[32mint divide_result = rtti_method_divide->Invoke<int>(&derived_both, 6, 3);[m
[32m+[m		[32mREQUIRE(divide_result == 2);[m
[32m+[m
[32m+[m		[32mCRTTIClass* rtti_class_derived = CRTTIClass::FindInStorage("engine::rtti::tests::CDerived");[m
[32m+[m		[32mCRTTIMethod* rtti_virtual_method = rtti_class_derived->FindMethodByName("GetVirtualBase");[m
[32m+[m		[32mREQUIRE(rtti_virtual_method != nullptr);[m
[32m+[m		[32mint virtual_result = rtti_virtual_method->Invoke<int>(&derived);[m
[32m+[m		[32mREQUIRE(virtual_result == 1);[m
[32m+[m	[32m}[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mTEST_CASE("RTTI Fields", "[RTTI]")[m
[32m+[m[32m{[m
[32m+[m	[32mSECTION("Fields are registered properly?")[m
[32m+[m	[32m{[m
[32m+[m		[32musing namespace engine::rtti;[m
[32m+[m		[32musing namespace engine::rtti::tests;[m
[32m+[m
[32m+[m		[32mCDerived derived;[m
[32m+[m		[32mCDerived2 derived2;[m
[32m+[m		[32mCDerivedBoth derived_both;[m
[32m+[m
[32m+[m		[32mCRTTIClass* rtti_class_derived = CRTTIClass::FindInStorage("engine::rtti::tests::CDerived");[m
[32m+[m		[32mREQUIRE(rtti_class_derived != nullptr);[m
[32m+[m		[32mCRTTIField* rtti_field = rtti_class_derived->FindFieldByName("m_PrivateInt");[m
[32m+[m		[32mREQUIRE(rtti_field != nullptr);[m
[32m+[m		[32mrtti_field->Set(&derived, 10);[m
[32m+[m		[32mREQUIRE(derived.GetPrivateInt() == 10);[m
[32m+[m		[32mint result_get = 0;[m
[32m+[m		[32mrtti_field->Get(&derived, result_get);[m
[32m+[m		[32mREQUIRE(result_get == 10);[m
[32m+[m	[32m}[m
 }[m
\ No newline at end of file[m
[1mdiff --git a/playground/tests/RTTITests.hpp b/playground/tests/RTTITests.hpp[m
[1mindex aeffffc..64cd607 100644[m
[1m--- a/playground/tests/RTTITests.hpp[m
[1m+++ b/playground/tests/RTTITests.hpp[m
[36m@@ -69,16 +69,122 @@[m [mnamespace engine::rtti[m
 		class IBase : public engine::rtti::IRTTIBase[m
 		{[m
 			RTTI_CLASS_API(IBase);[m
[32m+[m
[32m+[m			[32mpublic:[m
[32m+[m[41m			[m
[32m+[m				[32mvirtual ~IBase() = default;[m
[32m+[m				[32mint GetVirtualBase() { return 0; }[m
[32m+[m				[32mRTTI_METHOD_API(IBase, GetVirtualBase);[m
[32m+[m
[32m+[m				[32mint Add(int _a, int _b)[m
[32m+[m				[32m{[m
[32m+[m					[32mreturn _a + _b;[m
[32m+[m				[32m}[m
[32m+[m				[32mRTTI_METHOD_API(IBase, Add);[m
[32m+[m
[32m+[m				[32mint Subtract(int _a, int _b)[m
[32m+[m				[32m{[m
[32m+[m					[32mreturn _a - _b;[m
[32m+[m				[32m}[m
[32m+[m				[32mRTTI_METHOD_API(IBase, Subtract);[m
[32m+[m
[32m+[m				[32mint AddConst(int _a, int _b) const[m
[32m+[m				[32m{[m
[32m+[m					[32mreturn _a + _b;[m
[32m+[m				[32m}[m
[32m+[m				[32mRTTI_METHOD_API(IBase, AddConst);[m
[32m+[m
[32m+[m				[32mint SubtractConst(int _a, int _b) const[m
[32m+[m				[32m{[m
[32m+[m					[32mreturn _a - _b;[m
[32m+[m				[32m}[m
[32m+[m				[32mRTTI_METHOD_API(IBase, SubtractConst);[m
 		};[m
 //////////////////////////////////////////////////////////////////////////[m
[32m+[m		[32mclass IBase2 : public engine::rtti::IRTTIBase[m
[32m+[m		[32m{[m
[32m+[m			[32mRTTI_CLASS_API(IBase2);[m
[32m+[m
[32m+[m			[32mpublic:[m
[32m+[m[41m			[m
[32m+[m				[32mvirtual ~IBase2() = default;[m
[32m+[m
[32m+[m				[32mint Multiply(int _a, int _b)[m
[32m+[m				[32m{[m
[32m+[m					[32mreturn _a * _b;[m
[32m+[m				[32m}[m
[32m+[m				[32mRTTI_METHOD_API(IBase2, Multiply);[m
[32m+[m
[32m+[m				[32mint Divide(int _a, int _b)[m
[32m+[m				[32m{[m
[32m+[m					[32mreturn _a / _b;[m
[32m+[m				[32m}[m
[32m+[m				[32mRTTI_METHOD_API(IBase2, Divide);[m
[32m+[m
[32m+[m				[32mint MultiplyConst(int _a, int _b) const[m
[32m+[m				[32m{[m
[32m+[m					[32mreturn _a * _b;[m
[32m+[m				[32m}[m
[32m+[m				[32mRTTI_METHOD_API(IBase2, MultiplyConst);[m
[32m+[m
[32m+[m				[32mint DivideConst(int _a, int _b) const[m
[32m+[m				[32m{[m
[32m+[m					[32mreturn _a / _b;[m
[32m+[m				[32m}[m
[32m+[m				[32mRTTI_METHOD_API(IBase2, DivideConst);[m
[32m+[m		[32m};[m
[32m+[m
 		class CDerived : public IBase[m
 		{[m
 			RTTI_CLASS_API(CDerived, IBase);[m
[32m+[m[41m		[m
[32m+[m			[32mpublic:[m
[32m+[m
[32m+[m				[32mint GetPrivateInt() const[m
[32m+[m				[32m{[m
[32m+[m					[32mreturn m_PrivateInt;[m
[32m+[m				[32m}[m
[32m+[m
[32m+[m				[32mint GetVirtualBase() { return 1; }[m
[32m+[m				[32mRTTI_METHOD_API(CDerived, GetVirtualBase);[m
[32m+[m
[32m+[m			[32mprivate:[m
[32m+[m
[32m+[m				[32mint m_PrivateInt = 0;[m
[32m+[m				[32mRTTI_FIELD_API(CDerived, m_PrivateInt);[m
 		};[m
 //////////////////////////////////////////////////////////////////////////[m
 		class CDerived2 : public IBase[m
 		{[m
 			RTTI_CLASS_API(CDerived2, IBase);[m
[32m+[m
[32m+[m		[32mpublic:[m
[32m+[m
[32m+[m			[32mint GetPrivateInt() const[m
[32m+[m			[32m{[m
[32m+[m				[32mreturn m_PrivateInt;[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m		[32mprivate:[m
[32m+[m			[32mint m_PrivateInt = 0;[m
[32m+[m			[32mRTTI_FIELD_API(CDerived2, m_PrivateInt);[m
[32m+[m		[32m};[m
[32m+[m
[32m+[m		[32mclass CDerivedBoth : public IBase, public IBase2[m
[32m+[m		[32m{[m
[32m+[m			[32mRTTI_CLASS_API(CDerivedBoth, IBase, IBase2);[m
[32m+[m
[32m+[m		[32mpublic:[m
[32m+[m
[32m+[m			[32mint GetPrivateInt() const[m
[32m+[m			[32m{[m
[32m+[m				[32mreturn m_PrivateInt;[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32mprivate:[m
[32m+[m
[32m+[m				[32mint m_PrivateInt = 0;[m
[32m+[m				[32mRTTI_FIELD_API(CDerivedBoth, m_PrivateInt);[m
 		};[m
 //////////////////////////////////////////////////////////////////////////[m
 	}[m
[1mdiff --git a/playground/tests/ThreadPoolTests.cpp b/playground/tests/ThreadPoolTests.cpp[m
[1mindex 63eda5e..e3141d2 100644[m
[1m--- a/playground/tests/ThreadPoolTests.cpp[m
[1m+++ b/playground/tests/ThreadPoolTests.cpp[m
[36m@@ -1,5 +1,6 @@[m
 #include "engine/engine_pch.hpp"[m
 #include "ThreadPoolTests.hpp"[m
[32m+[m[32m#include "engine/pstd/FastFunction.hpp"[m
 [m
 #include <functional>[m
 [m
[36m@@ -7,26 +8,27 @@[m
 [m
 using namespace engine::threads;[m
 using namespace engine::threads::tests;[m
[32m+[m[32musing namespace engine::pstd;[m
 [m
 TEST_CASE("Thread Function Wrapper", "[Threads]")[m
 {[m
 	SECTION("Simple functions wrapper")[m
 	{[m
[31m-		CThreadFunctionWrapper<void> wrapper_void(MocVoid);[m
[32m+[m		[32mFastFunction<void> wrapper_void(MocVoid);[m
 		wrapper_void();[m
 [m
[31m-		CThreadFunctionWrapper<int> wrapper(MocNoSleepReturn);[m
[32m+[m		[32mFastFunction<int> wrapper(MocNoSleepReturn);[m
 		const int result = wrapper();[m
 		REQUIRE(result == s_MocReturnValue);[m
 [m
[31m-		CThreadFunctionWrapper<int, int, int> wrapper_add(MocAddTwoValues);[m
[32m+[m		[32mFastFunction<int, int, int> wrapper_add(MocAddTwoValues);[m
 		const int result_add = wrapper_add(1, 2);[m
 		REQUIRE(result_add == 3);[m
 [m
 		int a = 1;[m
 		int b = 2;[m
 		int res = 0;[m
[31m-		CThreadFunctionWrapper<void, int&, int&, int&> wrapper_ref(RefAddTwoValues);[m
[32m+[m		[32mFastFunction<void, int&, int&, int&> wrapper_ref(RefAddTwoValues);[m
 		wrapper_ref(a, b, res);[m
 		REQUIRE(res == 3);[m
 	}[m
[36m@@ -34,35 +36,35 @@[m [mTEST_CASE("Thread Function Wrapper", "[Threads]")[m
 	SECTION("Class method wrapper")[m
 	{[m
 		MocThreadNotSharedClass instance;[m
[31m-		CThreadFunctionWrapper<void> wrapper_void(&instance, &MocThreadNotSharedClass::MocVoid);[m
[32m+[m		[32mFastFunction<void> wrapper_void(&instance, &MocThreadNotSharedClass::MocVoid);[m
 		wrapper_void();[m
 [m
 		MocThreadNotSharedClass instance2;[m
[31m-		CThreadFunctionWrapper<int, int, int> wrapper_add(&instance2, &MocThreadNotSharedClass::MocAddTwoValues);[m
[32m+[m		[32mFastFunction<int, int, int> wrapper_add(&instance2, &MocThreadNotSharedClass::MocAddTwoValues);[m
 		const int result_add = wrapper_add(1, 2);[m
 		REQUIRE(result_add == 3);[m
 [m
 		int a = 1;[m
 		int b = 2;[m
 		int res = 0;[m
[31m-		CThreadFunctionWrapper<void, int&, int&, int&> wrapper_ref(&instance, &MocThreadNotSharedClass::RefAddTwoValues);[m
[32m+[m		[32mFastFunction<void, int&, int&, int&> wrapper_ref(&instance, &MocThreadNotSharedClass::RefAddTwoValues);[m
 		wrapper_ref(a, b, res);[m
 		REQUIRE(res == 3);[m
 	}[m
 [m
 	SECTION("Lambda wrapper")[m
 	{[m
[31m-		CThreadFunctionWrapper<void> wrapper_void([]() { std::string hello = "hello world"; hello[0] = 'X'; });[m
[32m+[m		[32mFastFunction<void> wrapper_void([]() { std::string hello = "hello world"; hello[0] = 'X'; });[m
 		wrapper_void();[m
 [m
[31m-		CThreadFunctionWrapper<int, int, int> wrapper_add([](int _a, int _b) { return _a + _b; });[m
[32m+[m		[32mFastFunction<int, int, int> wrapper_add([](int _a, int _b) { return _a + _b; });[m
 		const int result_add = wrapper_add(1, 2);[m
 		REQUIRE(result_add == 3);[m
 [m
 		int a = 1;[m
 		int b = 2;[m
 		int res = 0;[m
[31m-		CThreadFunctionWrapper<void> wrapper_ref([&a, &b, &res]() { res = a + b; });[m
[32m+[m		[32mFastFunction<void> wrapper_ref([&a, &b, &res]() { res = a + b; });[m
 		wrapper_ref();[m
 		REQUIRE(res == 3);[m
 	}[m
[36m@@ -70,13 +72,13 @@[m [mTEST_CASE("Thread Function Wrapper", "[Threads]")[m
 #if defined(BENCHMARKING)[m
 	SECTION("Performance tests vs STD")[m
 	{[m
[31m-		// Requirement: CThreadFunctionWrapper[m
[32m+[m		[32m// Requirement: FastFunction[m
 		// should be at least 3-4 times faster[m
 		// than standard library std::function.[m
 [m
 		BENCHMARK("Thread Function Wrapper")[m
 		{[m
[31m-			CThreadFunctionWrapper<int, int, int> wrapper(MocAddTwoValues);[m
[32m+[m			[32mFastFunction<int, int, int> wrapper(MocAddTwoValues);[m
 			const int res = wrapper(100, 200);[m
 		};[m
 [m
[1mdiff --git a/scripts/build/windows/premake5_windows.lua b/scripts/build/windows/premake5_windows.lua[m
[1mindex cba1641..4af5f01 100644[m
[1m--- a/scripts/build/windows/premake5_windows.lua[m
[1m+++ b/scripts/build/windows/premake5_windows.lua[m
[36m@@ -2,7 +2,7 @@[m
 project "Engine"[m
     kind "SharedLib"[m
     language "C++"[m
[31m-    cppdialect "C++20"[m
[32m+[m[32m    cppdialect "C++latest"[m
     targetdir("%{wks.location}/build/%{cfg.buildcfg}")[m
     basedir("../../../")[m
 [m
[36m@@ -10,8 +10,7 @@[m [mproject "Engine"[m
     pchheader("engine/engine_pch.hpp")[m
     pchsource("%{wks.location}/engine/engine_pch.cpp")[m
     files { "%{wks.location}/engine/**.hpp", "%{wks.location}/engine/**.cpp" }[m
[31m-    buildoptions{ "/utf-8" }[m
[31m-[m
[32m+[m[32m    buildoptions{ "/utf-8", "/Zc:preprocessor" }[m
 [m
     filter "configurations:*"[m
         includedirs { [m
[36m@@ -43,10 +42,10 @@[m [mproject "Game"[m
     defines { "FMT_HEADER_ONLY" }[m
     kind "ConsoleApp"[m
     language "C++"[m
[31m-    cppdialect "C++20"[m
[32m+[m[32m    cppdialect "C++latest"[m
     targetdir("%{wks.location}/build/%{cfg.buildcfg}")[m
     basedir("../../../")[m
[31m-    buildoptions{ "/utf-8" }[m
[32m+[m[32m    buildoptions{ "/utf-8", "/Zc:preprocessor" }[m
 [m
     files { "%{wks.location}/game/**.hpp", "%{wks.location}/game/**.cpp" }[m
 [m
[36m@@ -78,10 +77,10 @@[m [mproject "Playground"[m
     defines { "FMT_HEADER_ONLY" }[m
     kind "ConsoleApp"[m
     language "C++"[m
[31m-    cppdialect "C++20"[m
[32m+[m[32m    cppdialect "C++latest"[m
     targetdir("%{wks.location}/build/%{cfg.buildcfg}")[m
     basedir("../../../")[m
[31m-    buildoptions{ "/utf-8" }[m
[32m+[m[32m    buildoptions{ "/utf-8", "/Zc:preprocessor" }[m
 [m
     files { "%{wks.location}/playground/**.hpp", "%{wks.location}/playground/**.cpp" }[m
 [m
